Question 3.11: SinglyLinkedListOperations

The program starts off by initializing important variables like ListNode head (which creates the head of the Linked List) and int size (which contains the size of the Linked List). The class ListNode also has code that allows users to get value and move to the next node of the list. The constructor assigns a dummy to the head of the linked list, and assigns the integer 0 to variable size. 
	Condition A: The method public int size() returns the size of the linked list, and has the complexity of O(1).
	Condition B: public void printList() first initializes the current as head.next (node after the head) to start at the beginning of the list. Traverse through each of the nodes, print the value in the node, point the currentNode to the next node until the list until the end (node equals null). As this method traverses through each of the nodes while printing, it has a complexity of O(N).
	Condition C: public boolean hasValue (int x) first initializes the current as head.next (node after the head) to start at the beginning of the list. Then traverse through each value of the node and test for a match. If it finds the given value in the list, it returns true, but returns false when the whole list has been traversed but did not find a match. This method has a complexity of O(N) since it performs a similar function as the printList() by traversing through each node of the list.
Condition D: public void add(int x) first checks if the given value is already in the list. If not, then it increases the size of the list, creates a new node (with the given value inside), and inserts it after the head of the list. Although adding and removing from a linked list only has a complexity of O(1), this method utilizes the hasValue() method which has a complexity of O(N). Therefore, this method has a complexity of O(N).
Condition E: public void remove (int x) creates two temp nodes called prev and currentNode which essentially is i and i + 1. While traversing through the list, if the value is found, then “remove” the node by connecting the next pointer of i to the value of i + 2. Although removing a node only has the complexity of O(1), this method traverses through the list to find the value, essentially the same as the hasValue() method. Therefore, this method has the complexity of O(N) since it traverses through each of the nodes in the list. 

