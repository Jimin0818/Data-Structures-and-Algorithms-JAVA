SortingAlgorithms:
	The SortingAlgorithms class generates a random array, and records the time it took for different sorting algorithms to sort it.
	Condition 1: The generateArray() method creates a random array with a given size, and inserts random numbers (1-100) into the array and returns it. This method has a time complexity of O(N).
	Condition 2: Sort the array using Insertion Sort, Heap Sort, Merge Sort and Quicksort.
	Insertion Sort. This sort has two indexes: j and i (j-1). If the value at the rightmost index (j) is greater than the leftmost index (i), it inserts the value at i into j position and shifts the values of the array. The best-case scenario is when the list is presorted with no data movement. Time Complexity of O(N). The worst-case scenario is when the list is inverted. Then the algorithm will need p+1 comparisons for each pass. Time Complexity of O(N^2). The insertSortTime() method calculates the time for the insertion sort. It has a time complexity of N(1), but calls the insertionSort method which has complexity of between O(N) - O(N^2).
	Heap Sort: This sorting algorithm will build a max heap (the parent has to be greater than the child nodes), and then extract(delete) the max element of the array until it is empty. The heap() method is a helper method of heapSort which creates the max heap in sequential order. The method heapSort(int[] arr) will build a max heap using the heap() method and extract the max element in the array until it is empty. For the N nodes in the heap, it deletes the min, and stores the deleted key value at the end of the array, which has a time complexity of O(NLOGN). 
	Merge Sort: This sort algorithm will split the array into smaller subarrays until each subarray contains one value. It will then recursively sort them in sequential order and proceed to merge them back together.
The method mergeSort() method will divide the array into subarrays, sort the values, and then merge them back together. The time complexity of this sort algorithm is O(NLOGN). 
	Quick Sort: This sorting algorithm is called the divide-and-conquer recursive sorting algorithm. Choose one value from the array to be the pivot point and sort the array that all values less than the pivot will be on the left side and greater than the pivot will be on the right side. Then it recursively repeats the pivot and rearrange process until you reach the base case. If the length of the divided array extends the cutoff value, then it will stop dividing and sorting the array, and merge all the subarrays together. The method quickSort() will partition the array into two subarrays and then recursively sort each subarray using the partition() method. If there exists a cutoff, it checks if the length of the array is lower than the given cutoff value. If it is lower, then the insertionSort() method would be called to sort that subarray. The partition() method is a helper method used by the quickSort() method to divide the array into subarrays, determined by the high and low position. The time complexity of this method is O(N). The swap() method is used to swap values from an index from the given parameters i and j. The time complexity of this method O(1). This sorting algorithm has a best case time complexity of  O(NLOGN) when the pivot is assume to be always in the middle and a worst case complexity of O(N^2)
